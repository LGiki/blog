<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我，又回来了</title>
    <url>/2020/04/06/come-back-again/</url>
    <content><![CDATA[<p>是的，兜兜转转，我又重新回到了写博客这件事情上。前阵子把旧的博客给关掉之后才发现有时候心里头会突然憋着一些话想说，但却找不到地方表达出来，那时候才发现博客就是一个很好的载体，能让自己把想说的一些事情给记录下来。之前也陆陆续续建立过好几次博客了，每次都是从刚开始踌躇满志计划着每个月静下心来好好写一两篇博客，到后来渐渐变成了年更型博主，再到最后选择关掉博客。不过这次应该会坚持得比较久了吧…<a id="more"></a></p>
<p>疫情期间没出门，也一直没开学，天天宅在家里，就有了更多的时间来思考。人一闲下来思绪就容易开始四处发散，想想最近一年来自己的日常生活、经历的种种，发现我好像每天都在为各种各样的事情忙碌着，却从不曾静下心来思考思考自己的过往、现在与未来，感觉每天都过得没心没肺的样子。这几天闲了下来，想了想还是决定继续写博客来记录自己的生活，总得给自己的生活一个交代吧！嗯，哪管自己的博客有没有人看，把自己想说的话记录下来就是了，说不定几年过后还可以坐在电脑前，翻阅自己以前所写的文字来回味自己的种种过往呢。</p>
<p>想了一想，过去一年里最放松的时光大概就是去年国庆之后。那段时间终于忙完了一些大事，有了比较充足的时间，收了一台二手的Switch以及“塞尔达传说：旷野之息”卡带，然后就疯狂沉迷进了海拉鲁大陆的冒险生活中，前前后后大概玩了两个多礼拜，把游戏通关了。然而却一直不舍得卖掉塞尔达的卡带，时不时还得拿出来回味一下，再看看海拉鲁大地的美丽景色。塞尔达大概是继“尼尔机械纪元”之后，又一款能让我彻底沉迷进去的游戏。不得不佩服任天堂的游戏设计，开放世界真的是做得太棒了，每次在游戏里奔跑看到美丽的景色都让我觉得十分享受。未来，还要再重温一遍塞尔达，这次一定会放慢脚步，去体会游戏里还未曾发现的美好。</p>
<img src="/2020/04/06/come-back-again/mipha.jpg" class="" title="我永远都爱米法老婆">

<p>最近几天家里这边的天气不是很好，一直都是雨天，天气一下子冷了许多，敲键盘的手都是冰凉冰凉的，好羡慕北方有暖气。清明时节雨纷纷，说起来这个时间点要是不下点雨都有点奇怪了。看天气预报，明天开始好像就是晴天了，希望气温赶快回升，起码不至于写个代码都冻手冻脚的。</p>
<img src="/2020/04/06/come-back-again/rainbow.jpg" class="" title="🌈">

<p>写到这里，Spotify正好随机播放到《越长大越孤单》，哎，谁说不是呢…</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>国行Z500M(P027)刷入国际版固件及Root权限的获取</title>
    <url>/2020/07/19/convert-z500m-from-CN-to-WW-and-root/</url>
    <content><![CDATA[<p>这篇文章依然是来自于之前的旧博客，本来是不想恢复这篇博客的，但是偶然间发现这篇博客被某个恶心的采集站给采集过去了，并且出处信息全无。我一直以来就很讨厌这种把别人的劳动成果直接拿过来当成自己成果的行为。所以想想还是把这篇文章恢复了，并适当进行修改，文章里面记录的刷入国际版固件和获取Root权限的方法至今依旧可用。</p>
<a id="more"></a>

<p>手上有台一直放着吃灰的平板，华硕的 Zenpad 3S 10，型号是 P027，在上篇博文介绍的《<a href="https://lgiki.net/2020/06/08/extending-desktop-over-vnc/">通过 VNC 为 Linux 扩展第二显示器</a>》，我就是拿它当来当电脑的扩展显示器的，整体用下来效果还不错，写代码看文档方便多了，就是屏幕一直亮着还是挺费电的。</p>
<p>作为一个喜欢折腾各种电子产品的人，对于手上的这个平板当然还是想拿来折腾一下。这个平板有多个版本，我手上的是国行的，是最蛋疼的一个版本，ASUS 官方一直没给国行版本的 P027 更新系统，在国际版已经更新到 Android N (7.0) 很长一段时间了之后，国行版还是没有收到任何更新，一直停留在 Android M (6.0) ，多次找官方反馈国行版本的系统更新问题之后给的答复始终是：<del>更新系统可能导致系统不稳定，所以国行版本暂时没有更新计划</del>。喵喵喵？那为啥国际版更新了系统就不会不稳定？</p>
<p>没办法，那就只能自己寻找办法啦。毕竟 Android 是开放的，只要有一定的动手能力，那么就一定可以丰衣足食！</p>
<p>我首先想到的是下载国际版的固件尝试通过官方 Rec 刷入，于是就屁颠屁颠地跑到 ASUS 官方上找到了这个平板的固件下载页面，下载了最新的国际版固件，然后进官方 REC，开刷！然后…果不其然失败了。果然事情不会这么简单，看了一下 ROM 的 <code>updater-script</code> 文件，即刷机脚本，在这个文件的开头可以找到这么一句话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifelse(  getprop(<span class="string">"ro.product.name"</span>) == <span class="string">"OPEN_Zenpad"</span>, ui_print(<span class="string">"OPEN SKU device"</span>), (</span><br><span class="line">getprop(<span class="string">"ro.product.name"</span>) == <span class="string">"WW_P027"</span> || abort(<span class="string">"This package is for "</span>WW_P027<span class="string">" devices; this is a "</span><span class="string">" + getprop("</span>ro.product.name<span class="string">") + "</span><span class="string">"."</span>);</span><br><span class="line">) );</span><br></pre></td></tr></table></figure>

<p>看来官方还是留了一手，在刷入之前会先判断你的 product.name ，如果不是当前刷机包对应的版本直接退出安装过程。阻止了你在各个版本之间的互刷。暂时也没啥办法，毕竟官方 Rec 只能刷入官方签名的刷机包。</p>
<p>之后想到的就是尝试 Root，但是无一例外也失败了，其实在 XDA 上已经有人研究出这个平板的<a href="https://forum.xda-developers.com/android/development/tool-unlock-bootloader-asus-zenpad-10-t3730909" target="_blank" rel="noopener">解锁工具</a>以及在 Android N 下的 Root 方法了，甚至 <a href="https://forum.xda-developers.com/zenpad-10/development/twrp-asus-zenpad-3s-10-z500m-t3758333" target="_blank" rel="noopener">TWRP</a> 都已经有人编译好了，但是这些方法在 Android M 下用不了。不过之前在寻找 Root 的方法的时候在 <code>CN_13.6.6.2</code> 这个版本的固件上发现了存在 <a href="https://en.wikipedia.org/wiki/Dirty_COW" target="_blank" rel="noopener">Dirty COW</a> 漏洞，但是后来由于考试比较忙，一直没时间深入研究可否利用该漏洞 Root。</p>
<h1 id="需要"><a href="#需要" class="headerlink" title="需要"></a>需要</h1><ul>
<li>能正常通过USB连接平板的电脑（需要执行Fastboot和ADB指令）</li>
<li>CN固件的ASUS Z500M，且有充足的电量</li>
<li>连接稳定的数据线</li>
<li>一定的命令行使用经验</li>
<li>知道如何在开机的时候跳过或完成Google的设置向导（国际版固件带有Google Play框架）</li>
<li>胆大心细</li>
<li><strong>考虑清楚自己是否一定需要Root权限</strong></li>
</ul>
<h1 id="刷入国际版固件"><a href="#刷入国际版固件" class="headerlink" title="刷入国际版固件"></a>刷入国际版固件</h1><h2 id="备份你的所有个人数据"><a href="#备份你的所有个人数据" class="headerlink" title="备份你的所有个人数据"></a>备份你的所有个人数据</h2><p>做任何风险比较大的操作之前切记：<strong>备份所有的数据！备份所有的数据！备份所有的数据！</strong></p>
<h2 id="通过Fastboot刷入国际版固件"><a href="#通过Fastboot刷入国际版固件" class="headerlink" title="通过Fastboot刷入国际版固件"></a>通过Fastboot刷入国际版固件</h2><p>常规方法无法在国行CN版的系统上刷入国际版WW固件，所以这里需要一个小trick，在Fastboot模式下刷入国际版的固件。</p>
<p>首先下载这个文件并解压：</p>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/1hyPKSLdXIpQr6d-c2n9CoQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1hyPKSLdXIpQr6d-c2n9CoQ</a></p>
<p>提取码: a72k</p>
<p>MD5: 418ccfb7f73078d1f44dfe839b31f92c</p>
<p>SHA256: cb45da6d6e022dc3daa51507b763f8afc8c868ecf5a2fcb8fefdfc7223f0772c</p>
</blockquote>
<p>然后把平板关机，通过 <code>音量下 + 电源键</code> 开机，之后就会进入到一个启动选择界面。</p>
<p>在这个界面里：<strong>音量下是切换不同的选项，音量上是确认</strong>，这里我们通过音量下键让末尾的光标指向<code>Fastboot</code>，并按音量上确认，这样就成功进入了Fastboot模式。</p>
<p>进入到Fastboot模式之后，通过数据线将平板和电脑连接起来，确认电脑已经成功识别并且自动安装好了平板的相关驱动。</p>
<p>之后就可以找到解压出来的文件里面的 <code>flashall.cmd</code> 文件运行，这是一个批处理文件，会自动通过Fastboot刷入国际版固件。</p>
<p>然后你可以泡杯 <del>Java</del> (Coffee)，等待刷机完成。具体刷入用了多长时间我也记不清了，反正屏幕上会一直滚动刷入的日志，直到最后如果看到 <code>Download_PASS</code> 就是刷入成功了。</p>
<p>刷入国际版固件成功之后平板会自动重启，第一次重启大概需要 5 分钟左右的时间。重启完开机之后会进入首次开机设置界面，建议在这个设置界面上不要连接WiFi，等进入到桌面之后再连接 WiFi。</p>
<p>到这里，你已经成功从国行版固件刷入到国际版固件了。不过通过Fastboot刷入的国际版固件并不是最新的，还是Android M，所以还需要进一步通过官方固件升级到最新版本，直接到官方网站下载最新的国际版固件（<code>WW_V14.0210.1806.33</code>）：<a href="https://www.asus.com.cn/Tablets/ASUS-ZenPad-3S-10-Z500M/HelpDesk_BIOS/，下载之后放到平板内部存储的根目录下，之后系统通知栏会提示发现系统更新文件，是否立即更新，选择更新，然后等待系统自动更新完成即可。" target="_blank" rel="noopener">https://www.asus.com.cn/Tablets/ASUS-ZenPad-3S-10-Z500M/HelpDesk_BIOS/，下载之后放到平板内部存储的根目录下，之后系统通知栏会提示发现系统更新文件，是否立即更新，选择更新，然后等待系统自动更新完成即可。</a></p>
<p>自动更新完成之后到系统设置里面的“关于”中就能看到已经升级到 Android 7.0 了。</p>
<h1 id="Root-it"><a href="#Root-it" class="headerlink" title="Root it"></a>Root it</h1><h2 id="解锁Bootloader"><a href="#解锁Bootloader" class="headerlink" title="解锁Bootloader"></a>解锁Bootloader</h2><p>解锁Bootloader有两种选择，可以通过官方提供的解锁工具进行解锁，也可以使用XDA上的第三方解锁工具。这里我是通过XDA上的第三方解锁工具进行解锁的，因为我使用官方的解锁工具一直无法成功解锁。</p>
<h3 id="通过官方解锁工具解锁"><a href="#通过官方解锁工具解锁" class="headerlink" title="通过官方解锁工具解锁"></a>通过官方解锁工具解锁</h3><p>官方解锁工具的下载链接是：<a href="https://dlsvr04.asus.com/pub/ASUS/EeePAD/Zenpad/Z500M/0823-1812_SIGNED_UnlockTool_9.1.0.6_180806_fulldpi.apk.zip，下载之后解压出来是个" target="_blank" rel="noopener">https://dlsvr04.asus.com/pub/ASUS/EeePAD/Zenpad/Z500M/0823-1812_SIGNED_UnlockTool_9.1.0.6_180806_fulldpi.apk.zip，下载之后解压出来是个</a> apk 文件，安装上打开，之后根据提示一步步操作即可。</p>
<h3 id="通过XDA上的第三方工具解锁"><a href="#通过XDA上的第三方工具解锁" class="headerlink" title="通过XDA上的第三方工具解锁"></a>通过XDA上的第三方工具解锁</h3><p>由于我一直无法通过官方解锁工具成功解锁 Bootloader ，所以只好选择 XDA 上的第三方解锁工具进行解锁。这是第三方解锁工具的帖子链接：<a href="https://forum.xda-developers.com/android/development/tool-unlock-bootloader-asus-zenpad-10-t3730909。帖子里面有详细的说明，有两种解锁方法，这里选择第一种方法。" target="_blank" rel="noopener">https://forum.xda-developers.com/android/development/tool-unlock-bootloader-asus-zenpad-10-t3730909。帖子里面有详细的说明，有两种解锁方法，这里选择第一种方法。</a></p>
<h4 id="获取临时Root权限"><a href="#获取临时Root权限" class="headerlink" title="获取临时Root权限"></a>获取临时Root权限</h4><p>首先需要获取临时 Root 权限，其实获取的方法很简单，就两个步骤：通过 Magisk 修补 Boot -&gt; 通过 Fastboot 启动修补过的 Boot。下面详细说明：</p>
<h5 id="通过Magisk修补Boot"><a href="#通过Magisk修补Boot" class="headerlink" title="通过Magisk修补Boot"></a>通过Magisk修补Boot</h5><p>首先从 ASUS 官网下载的最新国际版刷机包（就是前文下载的那个 <code>WW_V14.0210.1806.33</code> 的刷机包）中解压出 <code>boot.img</code> 文件，然后将其放到平板中你能方便找到的任意地方。</p>
<p>平板上安装 Magisk Manager 并打开，选择<strong>安装</strong>，之后会有个<strong>选择安装方法</strong>的对话框，这里需要点击<strong>选择并修补一个文件</strong>，之后就会弹出一个文件选择框了，这里就选择刚刚解压出来的 <code>boot.img</code> 文件就行了，之后等待 Magisk Manager 自动修补 <code>boot.img</code> 文件，修补完成如下图所示：</p>
<img src="/2020/07/19/convert-z500m-from-CN-to-WW-and-root/Screenshot_20200719-181620.png" class="" title="Patch_boot_image">

<p>之后就能在平板内部存储的 Download 文件夹下找到一个名叫 <code>magisk_patched.img</code> 文件了。将这个文件拷贝到电脑上。</p>
<h5 id="通过Fastboot启动Magisk-Patched-Boot"><a href="#通过Fastboot启动Magisk-Patched-Boot" class="headerlink" title="通过Fastboot启动Magisk Patched Boot"></a>通过Fastboot启动Magisk Patched Boot</h5><p>之后平板关机进入 Fastboot 模式，并连接电脑，然后电脑上打开 CMD，通过以下指令使用 <code>magisk_patched.img</code> 文件引导平板开机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fastboot boot /path/to/magisk_patched.img</span><br></pre></td></tr></table></figure>

<p>PS：上面这个命令里面的<code>/path/to/magisk_patched.img</code>意思是magisk_patched.img这个文件的路径，可以先输入<code>fastboot boot</code>，再输入一个空格，之后直接将magisk_patched.img拉入终端中，终端会自动填入所拉入文件的路径。</p>
<p>这里如果你电脑上没有fastboot相关工具的话，可以使用cd指令切换当前工作目录到前文下载下来的线刷固件解压出来的文件夹下，这个里面有自带fastboot工具以及下文会用到的adb工具。</p>
<p>开机之后，再次打开Magisk Manager就能看到已经显示Magisk已安装了，但是此时还是临时的Root权限，重启就会没掉。</p>
<h4 id="解锁Bootloader-1"><a href="#解锁Bootloader-1" class="headerlink" title="解锁Bootloader"></a>解锁Bootloader</h4><p>有了临时 Root 权限我们就能解锁 Bootloader 啦！首先到这个<a href="https://forum.xda-developers.com/android/development/tool-unlock-bootloader-asus-zenpad-10-t3730909" target="_blank" rel="noopener">帖子</a>里面下载解锁工具：<code>unlock_tool_z500m_v0.6a.zip</code>，下载之后解压，放到平板上的 <code>/data/local/tmp</code> 目录下，具体如何操作这里不再详细说明，这一步我是使用 Root Explorer 完成的。</p>
<p>放好这个文件之后，数据线连接平板和电脑，平板记得打开 ADB 调试，然后执行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line"><span class="built_in">cd</span> /data/<span class="built_in">local</span>/tmp</span><br><span class="line">sh unlockbl.sh</span><br></pre></td></tr></table></figure>

<p>之后按照解锁脚本的提示，选择 <code>1. Unlock bootloader</code> ，之后根据提示输入 <code>Yes, I want to unlock</code> ，然后脚本就会自动进行解锁，完成之后如果看到以下提示就说明解锁成功了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Done!</span><br><span class="line">Please reboot your device.</span><br></pre></td></tr></table></figure>

<p>重启平板，可以看到开机的时候会显示<code>Orange State</code>，这就说明解锁成功了。</p>
<h2 id="刷入Magisk-Patched-Boot"><a href="#刷入Magisk-Patched-Boot" class="headerlink" title="刷入Magisk Patched Boot"></a>刷入Magisk Patched Boot</h2><p>解锁了 Bootloader 之后就可以对平板做任何修改了，下面讲讲如何获取永久 Root 权限（也就是如何刷入Magisk Patched Boot）。</p>
<p>依旧使用前文的方法，通过<code>fastboot boot /path/to/magisk_patched.img</code>开机，以获取临时的Root权限，然后打开 Magisk Manager，选择安装 Magisk，然后还是会弹出<strong>选择安装方法</strong>的对话框，这时候就要选择<strong>直接安装(推荐)</strong>了，之后 Magisk Manager 就会自动修补当前系统的 Boot 分区，并将其刷入。等提示成功之后，重启平板就会发现 Root 权限一直都在了。</p>
<p>应该也可通过<code>fastboot flash</code>命令直接在Fastboot模式下刷入magisk_patched.img，这个我也没尝试过，感兴趣的可以试试。</p>
<h1 id="刷入TWRP"><a href="#刷入TWRP" class="headerlink" title="刷入TWRP"></a>刷入TWRP</h1><p>之后就是刷入 TWRP 了，有了第三方 Rec 就可以为所欲为了！</p>
<p>首先到这个帖子里下载 <code>twrp-3.2.1-0-z500m.zip</code> ：<a href="https://forum.xda-developers.com/zenpad-10/development/twrp-asus-zenpad-3s-10-z500m-t3758333，下载完成之后解压，可以得到一个" target="_blank" rel="noopener">https://forum.xda-developers.com/zenpad-10/development/twrp-asus-zenpad-3s-10-z500m-t3758333，下载完成之后解压，可以得到一个</a> img 文件，这个就是 TWRP 的镜像了。将这个文件复制到平板中你能方便找到的地方，当然电脑上也要留一份这个文件，下面需要用到。</p>
<p>依旧很简单，平板关机并启动到 Fastboot，数据线连接到电脑，并使用以下指令使用 <code>twrp-3.2.1-0-z500m.img</code> 引导平板：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fastboot boot /path/to/twrp-3.2.1-0-z500m.img</span><br></pre></td></tr></table></figure>

<p>之后平板会启动到临时 TWRP 中，这时候可能会有一个警告界面，选择 <code>Keep System Read-only</code>。</p>
<p>然后就会进入到 TWRP 的主界面了，选择 <code>INSTALL</code> ，选择底部的 <code>Install Image</code> ，之后找到并选择你刚刚复制到平板里面的 <code>twrp-3.2.1-0-z500m.img</code> 文件，之后会出现刷入确认界面，这里选择刷入的分区为 <code>Recovery</code>，之后滑动底部滑块即可刷入 Recovery。</p>
<p>到这里为止，你就成功刷入 TWRP 了，重启到 Recovery 就可以直接进入到 TWRP 中。之后你就可以对你的平板为所欲为了！</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上操作只是记录我的操作过程，具体可以灵活操作，例如你也可以先刷入 TWRP，之后再在 TWRP 里面刷入 Magisk 以获取永久 Root 权限。</p>
<p>最后，补张效果图：</p>
<img src="/2020/07/19/convert-z500m-from-CN-to-WW-and-root/Screenshot_20200719-181519.png" class="" title="Magisk">]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>安卓</tag>
        <tag>Android</tag>
        <tag>流水账</tag>
      </tags>
  </entry>
  <entry>
    <title>为OpenWrt交叉编译MentoHUST</title>
    <url>/2020/09/14/cross-compile-mentohust-for-openwrt/</url>
    <content><![CDATA[<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>最近开始读研了，来到了新的学校，最重要的就是赶紧把路由器折腾好，有一个可靠的网络连接，愉快地网上冲浪。虽然手机套餐是无限流量的，可以通过手机开热点给电脑等其他设备使用，但是宿舍区人特别多，基站的承载量根本没法满足这么多用户的上网需求，网络特别慢，断断续续的，并且所谓无限流量实际上也不是真正的无限流量，超过了一定额度之后是会限速的。</p>
<p>这里不得不吐槽一下新学校的网络，简直是垄断中的垄断，虽然是电信、移动和联通这三家运营商都提供校园网络，但是只有联通是通过锐捷认证，能拿到学校内网IP的，其他两家都是各自拉线，无法得到学校内网IP。这就意味着如果需要在宿舍使用学校内网的资源，就必须开通联通的宽带。这里联通的宽带只有50Mbps，比我本科时所用的联通宽带100Mbps速度还慢，而套餐价格却是我本科的两倍左右。特别想念本科学校提供的10元/月教育网，再加上联通10元/月的宽带，一个月20元就能享受到100Mbps的网络连接，且提供了IPv6。</p>
<a id="more"></a>

<p>再吐槽一下新学校的方方面面，食堂比本科贵了不少，虽然种类是丰富了一点，但是觉得贵出来的这些钱并不值得。宿舍区离教学区特别远，所以满世界都是电动车、自行车，走在路上都得特别小心，宿舍区也因为四处的电动车显得特别拥挤，特别讨厌这样的环境。宿舍很小，柜子破破烂烂的，阳台也很小，晾衣服的地方也极不合理，衣服很不容易晾干。</p>
<p>如果可以，我真的是一刻都不想再待在这个破地方。本科的时候一直在骂本科的学校不好，到头来，真的觉得本科的学校是哪里都好。哎，有什么办法呢？读完研赶紧去工作吧。</p>
<p>言归正传，今天来聊聊如何为OpenWrt交叉编译MentoHUST，让OpenWrt代替电脑完成锐捷认证。</p>
<p>既然是要编译，首先肯定是需要准备编译环境的，主要就是交叉编译的工具链，幸运的是，OpenWrt已经为我们把所有需要的交叉编译工具链准备好了，我们只需要下载OpenWrt提供的SDK解压出来就能用了。</p>
<p>下面就开始详细介绍一下交叉编译的流程。</p>
<h1 id="需要的工具"><a href="#需要的工具" class="headerlink" title="需要的工具"></a>需要的工具</h1><ul>
<li>Linux环境（大部分主流发行版均可，我自己使用的是ArchLinux，你也可以选择自己喜欢的发行版）</li>
<li>OpenWrt SDK（下文会介绍）</li>
<li>稳定可靠的网络连接</li>
<li>耐心（编译因电脑配置的不同可能会需要较长的时间，需要耐心等待）</li>
</ul>
<h1 id="搭建编译环境"><a href="#搭建编译环境" class="headerlink" title="搭建编译环境"></a>搭建编译环境</h1><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><p>这一步参考OpenWrt的官方Wiki：<a href="https://openwrt.org/docs/guide-developer/build-system/install-buildsystem#examples_of_package_installations" target="_blank" rel="noopener">https://openwrt.org/docs/guide-developer/build-system/install-buildsystem#examples_of_package_installations</a></p>
<p>这个页面里针对各个Linux发行版都列出了所需的所有软件包，如果编译过程中还是有所欠缺，只需要根据报错信息安装对应的工具即可，这里不再详细展开。</p>
<h2 id="下载OpenWrt-SDK并解压"><a href="#下载OpenWrt-SDK并解压" class="headerlink" title="下载OpenWrt SDK并解压"></a>下载OpenWrt SDK并解压</h2><p>下载OpenWrt SDK之前需要先确定你的路由器CPU平台，可以到OpenWrt官网上通过路由器的型号查询，也可以通过搜索引擎去搜索。相信已经为路由器刷过OpenWrt的都知道自己路由器对应的是哪个平台。</p>
<p>这里我以我的Netgear WNDR3800举例，该路由器属于ar71xx平台，所以打开OpenWrt的<a href="https://mirrors4.tuna.tsinghua.edu.cn/openwrt/releases/19.07.4/targets/" target="_blank" rel="noopener">Download页面</a>（这里我使用tuna的镜像站以加快下载速度），可以看到有很多个目录，每个目录的名称对应的就是各个平台，这里我选择<a href="https://mirrors4.tuna.tsinghua.edu.cn/openwrt/releases/19.07.4/targets/ar71xx/" target="_blank" rel="noopener">ar71xx</a>，之后进入<a href="https://mirrors4.tuna.tsinghua.edu.cn/openwrt/releases/19.07.4/targets/ar71xx/generic/" target="_blank" rel="noopener">generic</a>目录，将页面拉到最底下可以看到：<a href="https://mirrors4.tuna.tsinghua.edu.cn/openwrt/releases/19.07.4/targets/ar71xx/generic/openwrt-sdk-19.07.4-ar71xx-generic_gcc-7.5.0_musl.Linux-x86_64.tar.xz" target="_blank" rel="noopener">openwrt-sdk-19.07.4-ar71xx-generic_gcc-7.5.0_musl.Linux-x86_64.tar.xz</a>，将其下载下来即可。</p>
<p>下载完成之后，解压：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvJf openwrt-sdk-19.07.4-ar71xx-generic_gcc-7.5.0_musl.Linux-x86_64.tar.xz</span><br></pre></td></tr></table></figure>

<h2 id="同步MentoHUST源码"><a href="#同步MentoHUST源码" class="headerlink" title="同步MentoHUST源码"></a>同步MentoHUST源码</h2><p>这里不用原版的MentoHUST，而是使用已经为OpenWrt打包好的<a href="https://github.com/KyleRicardo/MentoHUST-OpenWrt-ipk" target="_blank" rel="noopener">MentoHUST-OpenWrt-ipk</a></p>
<p>首先cd到OpenWrt SDK的目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> openwrt-sdk-19.07.4-ar71xx-generic_gcc-7.5.0_musl.Linux-x86_64</span><br></pre></td></tr></table></figure>

<p>然后通过git clone将MentoHUST源码同步到package目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/KyleRicardo/MentoHUST-OpenWrt-ipk.git package/mentohust</span><br></pre></td></tr></table></figure>

<h1 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h1><p>编译环境搭建完成之后就可以正式开始交叉编译了。</p>
<h2 id="更新feeds"><a href="#更新feeds" class="headerlink" title="更新feeds"></a>更新feeds</h2><p>首先需要更新feeds：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./scripts/feeds update</span><br></pre></td></tr></table></figure>

<p>然后安装libpcap feed：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./scripts/feeds install libpcap</span><br></pre></td></tr></table></figure>

<p>这里需要注意，OpenWrt SDK编译libpcap时只会编译出libpcap.so而不会编译出libpcap.a，但是mentohust需要libpcap.a，所以需要修改一下libpcap的Makefile，编辑<code>package/feeds/base/libpcap/Makefile</code>文件，将其中的</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> Package/libpcap/install</span><br><span class="line">        <span class="variable">$(INSTALL_DIR)</span> $(1)/usr/lib</span><br><span class="line">        <span class="variable">$(CP)</span> <span class="variable">$(PKG_INSTALL_DIR)</span>/usr/lib/libpcap.so.* $(1)/usr/lib/</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> Package/libpcap/install</span><br><span class="line">        <span class="variable">$(INSTALL_DIR)</span> $(1)/usr/lib</span><br><span class="line">        <span class="variable">$(CP)</span> <span class="variable">$(PKG_INSTALL_DIR)</span>/usr/lib/libpcap.&#123;a,so*&#125; $(1)/usr/lib/</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>

<p>即让编译libpcap的时候同时编译出libpcap.a</p>
<h2 id="menuconfig"><a href="#menuconfig" class="headerlink" title="menuconfig"></a>menuconfig</h2><p>接下来如要对编译配置文件进行简单的配置，这里直接使用menuconfig：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>这里需要关闭<code>Advanced configuration options (for developers)</code>中的<code>Automatic removal of build directories</code>：</p>
<img src="/2020/09/14/cross-compile-mentohust-for-openwrt/disable_auto_remove.png" class="" title="disable_auto_remove">

<p>并确保<code>Libraries</code>下的<code>libpcap</code>为<code>M</code>：</p>
<img src="/2020/09/14/cross-compile-mentohust-for-openwrt/libpcap.png" class="" title="libpcap">

<p><code>Network</code>下的<code>Ruijie</code>下的<code>mentohust</code>为<code>M</code>：</p>
<img src="/2020/09/14/cross-compile-mentohust-for-openwrt/mentohust.png" class="" title="mentohust">

<p>这样menuconfig就完成了，保存一下退出即可</p>
<h2 id="make"><a href="#make" class="headerlink" title="make!"></a>make!</h2><p>好了，到这一步所有的准备工作就都完成了，接下来就可以开始编译了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make package/mentohust/compile</span><br></pre></td></tr></table></figure>

<p>这一步需要在线下载libpcap的源码，所以请确保有一个良好的网络连接</p>
<p>如果没有什么意外情况的话，等编译完成之后就能在<code>bin/packages/mips_24kc/base</code>下找到libpcap和mentohust的ipk软件包了：</p>
<img src="/2020/09/14/cross-compile-mentohust-for-openwrt/ipk.png" class="" title="ipk">

<h1 id="安装到OpenWrt"><a href="#安装到OpenWrt" class="headerlink" title="安装到OpenWrt"></a>安装到OpenWrt</h1><p>接下来就只需要把编译出来的这两个ipk软件包安装进OpenWrt路由器就行了</p>
<h2 id="上传ipk到OpenWrt"><a href="#上传ipk到OpenWrt" class="headerlink" title="上传ipk到OpenWrt"></a>上传ipk到OpenWrt</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp libpcap1_1.9.1-2.1_mips_24kc.ipk root@192.168.1.1:/root/</span><br><span class="line">scp mentohust_0.3.1-1_mips_24kc.ipk root@192.168.1.1:/root/</span><br></pre></td></tr></table></figure>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>SSH连接到OpenWrt路由器，然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opkg install libpcap1_1.9.1-2.1_mips_24kc.ipk</span><br><span class="line">opkg install mentohust_0.3.1-1_mips_24kc.ipk</span><br></pre></td></tr></table></figure>

<h1 id="MentoHUST-LuCI-App"><a href="#MentoHUST-LuCI-App" class="headerlink" title="MentoHUST LuCI App"></a>MentoHUST LuCI App</h1><p>将上面编译出来地libpcap和mentohust安装到OpenWrt之后就能ssh连接到路由器，在命令行下面使用mentohust命令进行锐捷认证了，但是通过命令行进行锐捷认证总是不方便的。所以我们还需要一个管理页面，通过浏览器就能管理mentohust的配置和运行状态。</p>
<p>而因为管理页面只是执行一些命令的调用，并不需要像MentoHUST那样针对不同的CPU平台编译可执行文件，所以直接到这个仓库<a href="https://github.com/BoringCat/luci-app-mentohust" target="_blank" rel="noopener">https://github.com/BoringCat/luci-app-mentohust</a>的<a href="https://github.com/BoringCat/luci-app-mentohust/releases" target="_blank" rel="noopener">Release</a>页面下载作者编译好的ipk包然后跟前文一样使用<code>opkg install</code>安装到路由器即可。</p>
<img src="/2020/09/14/cross-compile-mentohust-for-openwrt/luci.png" class="" title="luci">

<p>至此，就可以愉快地让路由器代替电脑完成锐捷认证了，愉快享受网上冲浪的乐趣吧！XD</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>交叉编译</tag>
        <tag>mentohust</tag>
      </tags>
  </entry>
  <entry>
    <title>写于本科毕业之际</title>
    <url>/2020/05/25/end-four-years-at-jmu/</url>
    <content><![CDATA[<p>5月23号毕业论文线上答辩结束，整理答辩记录的时候才意识到本科就这么毕业了，“6月份分批安排学生回宿舍取行李，当天取完，当天回去，不能逗留”，想象过千万种毕业时的场景，却未曾想过本科生活会以这样的方式画上句号。甚至学士服👨‍🎓都没来得及穿，毕业照也没拍，毕业典礼也改成了☁️毕业典礼。按照往年的传统，学校还会请毕业生们在食堂免费吃一顿丰盛的自助餐，但是今年这情况显然是不可能了，谁能想到春节回家前在食堂吃的最后一餐竟然成了本科在食堂吃的最后一餐。想念西苑食堂二楼阿姨热情的招呼以及万人食堂二楼偏厅的炸🍗。在学校的时候天天吐槽学校的饭菜多么多么难吃，现在几个月不吃学校食堂反倒觉得食堂的饭菜很香。<a id="more"></a></p>
<p>答辩完的第二天好好睡了一觉，醒来之后有种不太真实的感觉。</p>
<p>回想起来，我这一届的学生从大一开学就经历了许多磨难。刚开始军训没几天，就遭遇了强台风“<a href="https://en.wikipedia.org/wiki/Typhoon_Meranti" target="_blank" rel="noopener">莫兰蒂</a>”。作为一个土生土长的福建人，长这么大也没遇见过这么大的台风。台风是夜里登陆厦门的，当天晚上睡梦中就被宿舍外呼呼的风声给吵醒了，随着台风越来越接近厦门，树木倒掉的声音、玻璃破碎的声音不绝于耳，后面实在太困就睡着了。第二天早上醒来大概是8点多，手机没信号。走出宿舍一看，学校的树倒了一大片，断电断网断水，连食堂都没水没电煮饭，只能简单煮点面条。</p>
<img src="/2020/05/25/end-four-years-at-jmu/IMG_0603.jpg" class="" title="🌀">

<p>不过也正是因为这台风，军训暂停了一段时间，直到国庆放假回去才继续军训，那会儿天气已经不再那么燥热。当然，军训暂停的这段时间，学校也没让我们闲着，让我们去帮忙搬运学校里倒下的树木，别看那树木体积不大，里面可都是实心的，搬起来还真挺费劲，第一次体会到了搬运工的辛苦。</p>
<p>对了，台风来临的前一天傍晚，夕阳真的很好看！</p>
<img src="/2020/05/25/end-four-years-at-jmu/IMG_0724.jpg" class="" title="🌇">

<p>现在马上毕业却遇上了疫情，开学时间从2月16日一拖再拖，直到前几天辅导员开会通知了不开学，等6月份回宿舍取走自己的行李。这期间见证了太多的历史，什么东西都改成线上的了：网课、网上答辩、网上面试，好多事情都是以前从未想象过的。经历了这一次疫情也不得不感叹人类在大自然面前的渺小，希望全球的疫情能早日结束，大家都能重新回到正常的生活轨道。</p>
<p>想一想我本科这四年，用“平淡”二字来概括最合适不过了。没有作出什么轰轰烈烈的事情，甚至学校的各种社团都没参加，更没有谈恋爱，有的只是平平淡淡的四年生活，每天三点一线往返于宿舍—教室—食堂。累了就打打游戏，有时间了就看看书、写写代码，心情不好的时候就去操场上跑几圈。有时候自己都会觉得这样的大学生活是不是太没意思了，但是再想想，也正是因为这样的生活，我有了更多的时间可以做一些自己喜欢的事情，有了时间可以去研究一些自己感兴趣的东西，所以本科期间自学了蛮多有意思的知识。虽然这样的本科生活似乎挺不错的，但还是经常会觉得少经历了些有趣的事，不像是一个年轻人应该有的状态，未来希望自己可以多出去走走，多看看外面的风景。</p>
<p>这四年，说长不长，说短也不短。要说本科这四年教会了我什么，我想，除了课本上那些条条框框的知识点之外，更多的还是一些为人处世的道理。跟形形色色的人打交道，听到来自五湖四海的故事，也渐渐能体会到人生百态和大人们口中常说的社会的复杂。看待一些事情的角度也变得越来越复杂，也不知道这是好是坏，还是更喜欢童年时候的无忧无虑与单纯。</p>
<p>四年，也发现父母真的是一点点变老了。高中那会儿还经常能一周回家一趟，所以看不太出来父母的变化。上了大学之后，经常是久久才会回家一趟，回家了也就待几天就又急匆匆回学校了，发现父母真的是在一点点变老。告诉自己，接下来要好好努力，不让父母失望，也争取能早日报答父母。本科期间用自己赚到的一点钱，帮父母都换了手机还是觉得挺开心的。</p>
<p>都说大学毕业之后有些人可能这辈子就再也见不到了，而现在还没毕业，班上的同学们就已经各奔东西。也不知道以后还有没有机会再聚在一起喝酒吹牛逼、讲故事、谈人生。嗯，不管怎么样，都希望曾经跟我一起学习过的你们未来能拥有一个灿烂的人生。临近毕业，陆陆续续听到一些同学找到工作的消息、考研复试通过的消息，打心底祝福你们。</p>
<p>虽然在集美大学的时候，天天跟同学吐槽着集美大学这里不好那里不好，但是到了真正要跟这所学校说再见的时候，心中却依然是充满了不舍。再见了，集美大学，未来我一定会找个时间回来和你好好合个影，再尝一尝当年一直吐槽的食堂饭菜，看一看来不及停下脚步欣赏的风景。</p>
<p>也祝今年毕业的同龄人都能幸福，面朝大海，春暖花开。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>本科</tag>
        <tag>毕业</tag>
        <tag>大学</tag>
      </tags>
  </entry>
  <entry>
    <title>通过VNC为Linux扩展第二显示器</title>
    <url>/2020/06/08/extending-desktop-over-vnc/</url>
    <content><![CDATA[<p>这篇文章是旧博客的备份恢复，因为时间久远，其中的信息可能已经过时，仅供参考。</p>
<p>手上有一台吃灰挺久了的安卓平板，一直没有怎么使用，更多的是用来调试 Android App 以及偶尔拿它来看看视频或者盖泡面。</p>
<p>最近写代码越发觉得笔记本单屏很难受，查文档得在Chrome跟IDE之间来回切换。而又苦于没有钱买显示器，并且宿舍也没有这么大的地方能够同时放下笔记本跟显示器。就想着能否将这平板利用起来，用它来当电脑的扩展显示器，因为我日常使用比较多的是ArchLinux，Windows基本只用来打游戏，所以就开始研究起如何在Linux下将平板作为扩展显示器。然后真就在Arch Linux Forums上找到了一篇<a href="https://bbs.archlinux.org/viewtopic.php?id=191555" target="_blank" rel="noopener">帖子</a>描述了通过VNC为Linux扩展第二显示器的方法。不过这个方法中有些步骤在我的电脑上有点问题，需要修改一下才能正常使用。</p>
<p>下面就记录一下如何通过VNC为Linux扩展第二显示器。</p>
<a id="more"></a>

<img src="/2020/06/08/extending-desktop-over-vnc/overview.png" class="" title="💻">

<h1 id="给-Xorg-添加-VIRTUAL-显示输出设备"><a href="#给-Xorg-添加-VIRTUAL-显示输出设备" class="headerlink" title="给 Xorg 添加 VIRTUAL 显示输出设备"></a>给 Xorg 添加 VIRTUAL 显示输出设备</h1><p>打开终端，执行 <code>xrandr</code> 指令，该指令会输出当前系统所有可用的显示输出设备，以及每个显示设备可设置的显示模式，如下图是我在我电脑上执行该指令的输出结果：</p>
<img src="/2020/06/08/extending-desktop-over-vnc/xrandr_result.png" class="" title="xrandr">

<p>如果能在输出中找到以 <code>VIRTUAL</code> 开头的设备（如上图中的 VIRTUAL1 以及 VIRTUAL2），就表明当前系统中已经有 <code>VIRTUAL</code> 输出设备了，可以直接进入下一个步骤。</p>
<p>如果没能找到 <code>VIRTUAL</code> 开头的设备的话，就需要在 <code>/usr/share/X11/xorg.conf.d/</code> 下创建一个 conf 文件，添加 <code>VIRTUAL</code> 设备。具体方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /usr/share/X11/xorg.conf.d/20-intel.conf</span><br></pre></td></tr></table></figure>

<p>然后插入以下配置文本，并保存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Section &quot;Device&quot;</span><br><span class="line">    Identifier &quot;intelgpu0&quot;</span><br><span class="line">    Driver &quot;intel&quot; Option</span><br><span class="line">    &quot;VirtualHeads&quot; &quot;2&quot;</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>

<p>如下图所示：</p>
<img src="/2020/06/08/extending-desktop-over-vnc/3.png" class="" title="💻">

<p>保存该文件之后需要 logout ，之后重新登录。再次执行 <code>xrandr</code> ，这时候你应该就能在 <code>xrandr</code> 的输出结果中找到 <code>VIRTUAL</code> 显示输出设备了。</p>
<h1 id="生成显示模式"><a href="#生成显示模式" class="headerlink" title="生成显示模式"></a>生成显示模式</h1><p>之后需要为你的平板或者其他作为 Linux 第二显示器设备生成一个显示模式。</p>
<p>例如我手上的这台平板的分辨率是 2048 * 1536，我就需要为它生成一个 2048 * 1536 的显示模式。</p>
<p>如果你手上的设备的分辨率对应的显示模式在之前 <code>xrandr</code> 的输出结果中已经存在的话，则可以跳过这一步，直接进入下一个步骤，不过你需要记住 <code>xrandr</code> 输出的显示模式列表中的第一例就是显示模式的名称。例如你的平板的分辨率为 1920 * 1080，而在 <code>xrandr</code> 的输出结果中发现了名为 <code>1920x1080</code> 的显示模式，那就可以直接进入下一个步骤了，不用再为它手动生成一个显示模式。</p>
<p>下面我就以我平板的分辨率 2048 * 1536 说明如何生成一个显示模式。</p>
<p>首先，我们需要为显示模式生成一个 <code>Modeline</code>，执行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gtf 2048 1536 60</span><br></pre></td></tr></table></figure>

<p>命令中的 2048 跟 1536 这两个参数用于指定分辨率，而末尾的 60 则用于指定刷新率，因为我们这里并不是连接一个实际的显示器，所以刷新率这个参数可以任意给，这里习惯上给了个 60 作为刷新率。</p>
<p>执行完这条指令之后会得到这样的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 2048x1536 @ 60.00 Hz (GTF) hsync: 95.34 kHz; pclk: 266.95 MHz</span><br><span class="line">  Modeline &quot;2048x1536_60.00&quot; 266.95 2048 2200 2424 2800 1536 1537 1540 1589 -HSync +Vsync</span><br></pre></td></tr></table></figure>
<p>我们这里需要记录下 <code>Modeline</code> 之后的那部分字符串，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;2048x1536_60.00&quot; 266.95 2048 2200 2424 2800 1536 1537 1540 1589 -HSync +Vsync</span><br></pre></td></tr></table></figure>
<p>有了这串字符串之后，我们就可以添加一个新的显示模式了，执行 <code>xrandr --newmode 前面记录下的字符串</code>，就能创建一个新的显示模式了，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr --newmode <span class="string">"2048x1536_60.00"</span> 266.95 2048 2200 2424 2800 1536 1537 1540 1589 -HSync +Vsync</span><br></pre></td></tr></table></figure>
<p>其中 <code>--newmode</code> 这个参数的值就是我们前面记录下来的那一长串。</p>
<p>而 <code>2048x1536_60.00</code> 就是我们添加的显示模式的名称。</p>
<h1 id="为-VIRTUAL-显示输出设备添加显示模式"><a href="#为-VIRTUAL-显示输出设备添加显示模式" class="headerlink" title="为 VIRTUAL 显示输出设备添加显示模式"></a>为 VIRTUAL 显示输出设备添加显示模式</h1><p>有了 VIRTUAL 显示设备，也有了我们所需的显示模式之后，我们就需要将其两者结合起来，将显示模式添加给显示设备，让 VIRTUAL 显示设备支持我们所需的显示模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr --addmode VIRTUAL1 2048x1536_60.00</span><br><span class="line"><span class="comment">#                    ⬆          ⬆</span></span><br><span class="line"><span class="comment">#                 显示设备    显示模式</span></span><br></pre></td></tr></table></figure>

<p>该指令的 <code>--addmode</code> 参数需要传入两个值，其中第一个为显示设备名称，这里指定为 <code>VIRTUAL1</code>，第二个为显示模式，这里就指定为前面生成的显示模式 <code>2048x1536_60.00</code>。</p>
<p>这时候再执行 <code>xrandr</code> 指令，你就能在 VIRTUAL1 这个显示输出设备底下看到我们刚刚创建的显示模式了：</p>
<img src="/2020/06/08/extending-desktop-over-vnc/4.png" class="" title="💻">

<h1 id="开启-VIRTUAL-显示输出设备"><a href="#开启-VIRTUAL-显示输出设备" class="headerlink" title="开启 VIRTUAL 显示输出设备"></a>开启 VIRTUAL 显示输出设备</h1><p>这时候 VIRTUAL 显示输出设备的状态还是 disconnect，我们接下来就需要开启它，之后就能通过 VNC 将 VIRTUAL 显示输出设备的画面给转发出去了。</p>
<p>这一个步骤也很简单，只需要执行这么一句指令就行了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr --output VIRTUAL1 --mode 2048x1536_60.00 --right-of eDP1</span><br><span class="line"><span class="comment">#                  ⬆                  ⬆                      ⬆</span></span><br><span class="line"><span class="comment">#                显示设备            显示模式            你当前的显示设备</span></span><br></pre></td></tr></table></figure>
<p>解释一下这条指令中的参数：</p>
<ul>
<li><code>--output</code>：这个参数指定的就是显示设备了，也就是 VIRTUAL1 显示输出设备。</li>
<li><code>--mode</code>：这个参数用于指定显示模式，这里就指定为我们前面所生成的显示模式 2048x1536_60.00。</li>
<li><code>--right-of</code>：这个参数用于指定要开启的显示设备拼接到某个设备的右边。例如我这里指定了 VIRTUAL1 拼接到我笔记本屏幕 eDP1 的右边。这个参数其实是可选的，你也可以选择 <code>--left-of</code> 等等。</li>
</ul>
<h1 id="通过-VNC-转发-VIRTUAL-显示输出设备的画面"><a href="#通过-VNC-转发-VIRTUAL-显示输出设备的画面" class="headerlink" title="通过 VNC 转发 VIRTUAL 显示输出设备的画面"></a>通过 VNC 转发 VIRTUAL 显示输出设备的画面</h1><p>这时候 VIRTUAL 显示设备其实已经启用了，你可以注意到，你的鼠标已经可以移动到你电脑显示器的范围之外了，接下来只需要通过 VNC 将 VIRTUAL 显示输出设备的画面转发出去就行了。<br>首先，执行 <code>xrandr</code> 指令，得到以下输出结果：</p>
<img src="/2020/06/08/extending-desktop-over-vnc/5.png" class="" title="💻">

<p>这里需要记住 VIRTUAL1 设备之后所显示的一串表达式（即上图中选中的部分）：<code>2048x1536+1920+0</code></p>
<p>之后执行以下指令即可通过 VNC 将 VIRTUAL 显示输出设备的画面转发出去：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x11vnc -clip 2048x1536+1920+0 -forever</span><br></pre></td></tr></table></figure>

<p>其中 <code>-clip</code> 参数的值就是前面使用 <code>xrandr</code> 指令所查看到的 VIRTUAL1 设备之后的那一串表达式。 <code>-forever</code> 参数则是告诉 x11vnc 不要在设备断开连接之后就关闭 VNC。<br>默认的端口号是 <code>5900</code>。</p>
<h1 id="如何关闭"><a href="#如何关闭" class="headerlink" title="如何关闭"></a>如何关闭</h1><ul>
<li>首先通过 Ctrl + C 停止 <code>x11vnc</code></li>
<li>然后关闭 VIRTUAL1 显示设备的输出：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr --output VIRTUAL1 --off</span><br></pre></td></tr></table></figure></li>
<li>（可选）从 VIRTUAL1 显示设备中删除前面添加的显示模式：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr --delmode VIRTUAL1 2048x1536_60.00</span><br><span class="line"><span class="comment">#                    ⬆           ⬆</span></span><br><span class="line"><span class="comment">#                  显示设备    显示模式</span></span><br></pre></td></tr></table></figure></li>
<li>（可选）删除前面生成的显示模式：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr --rmmode 2048x1536_60.00</span><br><span class="line"><span class="comment">#                     ⬆</span></span><br><span class="line"><span class="comment">#                  显示模式</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>如何绘制出精美的神经网络模型结构图</title>
    <url>/2020/07/24/how-to-visualize-neural-network-architectures/</url>
    <content><![CDATA[<p>最近需要绘制机器学习的模型结构图，但是通过<a href="https://draw.io/" target="_blank" rel="noopener">draw.io</a>画出来的图总感觉不如别人paper里的好看，所以就去查找了一下有没有用于绘制机器学习模型结构图的工具，顺便整理成这篇文章。虽然这篇文章标题里说的是“如何绘制精美的神经网络模型结构图”，但实际上这篇文章更多的是收集一些神经网络模型的可视化工具。希望能对同样遇到这个问题的人有所帮助。</p>
<a id="more"></a>

<p>PS：可以通过这个页面左侧的文章引导框快速定位到某个工具</p>
<h1 id="框架无关"><a href="#框架无关" class="headerlink" title="框架无关"></a>框架无关</h1><h2 id="NN-SVG"><a href="#NN-SVG" class="headerlink" title="NN-SVG"></a>NN-SVG</h2><p>Github地址：<a href="https://github.com/alexlenail/NN-SVG" target="_blank" rel="noopener">https://github.com/alexlenail/NN-SVG</a></p>
<p>使用方式：浏览器</p>
<p>在线使用：<a href="http://alexlenail.me/NN-SVG/LeNet.html" target="_blank" rel="noopener">http://alexlenail.me/NN-SVG/LeNet.html</a></p>
<p>该工具支持导出SVG格式的矢量图形文件</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/nn_svg.png" class="" title="FCNN">

<p>提供了三种不同的神经网络结构图模板：</p>
<ol>
<li><p>FCNN Style</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/nn_svg_fcnn.svg" class="" title="FCNN">
</li>
<li><p>LeNet Style</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/nn_svg_lenet.svg" class="" title="LeNet">
</li>
<li><p>AlexNet Style</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/nn_svg_alexnet.svg" class="" title="AlexNet">

</li>
</ol>
<h2 id="draw-convnet"><a href="#draw-convnet" class="headerlink" title="draw_convnet"></a>draw_convnet</h2><p>Github地址：<a href="https://github.com/gwding/draw_convnet" target="_blank" rel="noopener">https://github.com/gwding/draw_convnet</a></p>
<p>使用方式：命令行</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/draw_convnet.png" class="" title="draw_convnet">

<h2 id="PlotNeuralNet"><a href="#PlotNeuralNet" class="headerlink" title="PlotNeuralNet"></a>PlotNeuralNet</h2><p>Github地址：<a href="https://github.com/HarisIqbal88/PlotNeuralNet" target="_blank" rel="noopener">https://github.com/HarisIqbal88/PlotNeuralNet</a></p>
<p>使用方式：命令行</p>
<p>通过Python编写模型的结构代码，然后调用LaTeX输出为pdf格式的文档</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/PlotNeuralNet.png" class="" title="PlotNeuralNet">

<h2 id="Netron"><a href="#Netron" class="headerlink" title="Netron"></a>Netron</h2><p>Github地址：<a href="https://github.com/lutzroeder/Netron" target="_blank" rel="noopener">https://github.com/lutzroeder/Netron</a></p>
<p>使用方式：客户端 / 浏览器</p>
<p>看这名字多少能猜出来这又是一款基于Electron开发的程序，该程序支持非常多的文件格式：</p>
<blockquote>
<p><strong>ONNX</strong> (<code>.onnx</code>, <code>.pb</code>, <code>.pbtxt</code>), <strong>Keras</strong> (<code>.h5</code>, <code>.keras</code>), <strong>Core ML</strong> (<code>.mlmodel</code>), <strong>Caffe</strong> (<code>.caffemodel</code>, <code>.prototxt</code>), <strong>Caffe2</strong> (<code>predict_net.pb</code>), <strong>Darknet</strong> (<code>.cfg</code>), <strong>MXNet</strong> (<code>.model</code>, <code>-symbol.json</code>), <strong>Barracuda</strong> (<code>.nn</code>), <strong>ncnn</strong> (<code>.param</code>), <strong>Tengine</strong> (<code>.tmfile</code>), <strong>TNN</strong> (<code>.tnnproto</code>), <strong>UFF</strong> (<code>.uff</code>) and <strong>TensorFlow Lite</strong> (<code>.tflite</code>)</p>
</blockquote>
<p>同时也实验性地支持以下文件格式：</p>
<blockquote>
<p><strong>TorchScript</strong> (<code>.pt</code>, <code>.pth</code>), <strong>PyTorch</strong> (<code>.pt</code>, <code>.pth</code>), <strong>Torch</strong> (<code>.t7</code>), <strong>Arm NN</strong> (<code>.armnn</code>), <strong>BigDL</strong> (<code>.bigdl</code>, <code>.model</code>), <strong>Chainer</strong> (<code>.npz</code>, <code>.h5</code>), <strong>CNTK</strong> (<code>.model</code>, <code>.cntk</code>), <strong>Deeplearning4j</strong> (<code>.zip</code>), <strong>MediaPipe</strong> (<code>.pbtxt</code>), <strong>ML.NET</strong> (<code>.zip</code>), <strong>MNN</strong> (<code>.mnn</code>), <strong>PaddlePaddle</strong> (<code>.zip</code>, <code>__model__</code>), <strong>OpenVINO</strong> (<code>.xml</code>), <strong>scikit-learn</strong> (<code>.pkl</code>), <strong>TensorFlow.js</strong> (<code>model.json</code>, <code>.pb</code>) and <strong>TensorFlow</strong> (<code>.pb</code>, <code>.meta</code>, <code>.pbtxt</code>, <code>.ckpt</code>, <code>.index</code>)</p>
</blockquote>
<p>可以说是把常用的机器学习框架都支持了一遍，支持导出为PNG和SVG格式的图像文件</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/netron.png" class="" title="Netron">

<h2 id="Moniel"><a href="#Moniel" class="headerlink" title="Moniel"></a>Moniel</h2><p>Github地址：<a href="https://github.com/mlajtos/moniel" target="_blank" rel="noopener">https://github.com/mlajtos/moniel</a></p>
<p>可以通过该程序所定义的语法格式生成计算图的图像</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/moniel.png" class="" title="Moniel">

<h1 id="框架相关"><a href="#框架相关" class="headerlink" title="框架相关"></a>框架相关</h1><p>PS：以下框架的顺序是按照字母表顺序排序的</p>
<h2 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h2><h3 id="caffe-draw-py"><a href="#caffe-draw-py" class="headerlink" title="caffe/draw.py"></a>caffe/draw.py</h3><p>在Caffe中可以使用<a href="https://github.com/BVLC/caffe/blob/master/python/caffe/draw.py" target="_blank" rel="noopener">caffe/draw.py</a>来绘制NetParameter protobuffer：</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/caffe.png" class="" title="Caffe">

<h3 id="Netscope-CNN-Analyzer"><a href="#Netscope-CNN-Analyzer" class="headerlink" title="Netscope CNN Analyzer"></a>Netscope CNN Analyzer</h3><p>项目主页：<a href="http://dgschwend.github.io/netscope/quickstart.html" target="_blank" rel="noopener">http://dgschwend.github.io/netscope/quickstart.html</a></p>
<p>使用方式：浏览器</p>
<p>支持可视化Caffe prototxt格式的模型</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/netscope_CNN_analyzer.png" class="" title="netscope_CNN_analyzer">

<h2 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h2><h3 id="keras-sequential-ascii"><a href="#keras-sequential-ascii" class="headerlink" title="keras-sequential-ascii"></a>keras-sequential-ascii</h3><p>Github地址：<a href="https://github.com/stared/keras-sequential-ascii/" target="_blank" rel="noopener">https://github.com/stared/keras-sequential-ascii/</a></p>
<p>使用方式：命令行</p>
<p>可将Keras的Sequential model通过ASCII字符画展示出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         OPERATION           DATA DIMENSIONS   WEIGHTS(N)   WEIGHTS(%)</span><br><span class="line"></span><br><span class="line">             Input   #####      3   32   32</span><br><span class="line">BatchNormalization    μ|σ  -------------------        64     0.1%</span><br><span class="line">                     #####      3   32   32</span><br><span class="line">     Convolution2D    \|&#x2F;  -------------------       448     0.8%</span><br><span class="line">              relu   #####     16   30   30</span><br><span class="line">     Convolution2D    \|&#x2F;  -------------------      2320     4.3%</span><br><span class="line">              relu   #####     16   28   28</span><br><span class="line">      MaxPooling2D   Y max -------------------         0     0.0%</span><br><span class="line">                     #####     16   14   14</span><br><span class="line">     Convolution2D    \|&#x2F;  -------------------       272     0.5%</span><br><span class="line">              tanh   #####     16   14   14</span><br><span class="line">           Flatten   ||||| -------------------         0     0.0%</span><br><span class="line">                     #####        3136</span><br><span class="line">             Dense   XXXXX -------------------     50192    94.1%</span><br><span class="line">                     #####          16</span><br><span class="line">           Dropout    | || -------------------         0     0.0%</span><br><span class="line">                     #####          16</span><br><span class="line">             Dense   XXXXX -------------------        51     0.1%</span><br><span class="line">           softmax   #####           3</span><br></pre></td></tr></table></figure>

<h3 id="Keras-Visualization"><a href="#Keras-Visualization" class="headerlink" title="Keras Visualization"></a>Keras Visualization</h3><p>Keras可以通过官方提供的<a href="https://keras.io/api/utils/model_plotting_utils/" target="_blank" rel="noopener">Model plotting utilities</a>来绘制Keras模型图</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/keras_visualization.png" class="" title="keras_visualization">

<h3 id="ConX"><a href="#ConX" class="headerlink" title="ConX"></a>ConX</h3><p>主页：<a href="https://conx.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">https://conx.readthedocs.io/en/latest/index.html</a></p>
<p>一个Python库，可用于绘制带激活的神经网络</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/conx.png" class="" title="Conx">

<h3 id="Quiver"><a href="#Quiver" class="headerlink" title="Quiver"></a>Quiver</h3><p>Github地址：<a href="https://github.com/keplr-io/quiver" target="_blank" rel="noopener">https://github.com/keplr-io/quiver</a></p>
<p>可交互的卷积网络特征可视化</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/quiver.gif" class="" title="Quiver">

<h3 id="Net2Vis"><a href="#Net2Vis" class="headerlink" title="Net2Vis"></a>Net2Vis</h3><p>主页：<a href="https://viscom.net2vis.uni-ulm.de/" target="_blank" rel="noopener">https://viscom.net2vis.uni-ulm.de/</a></p>
<p>使用方式：浏览器</p>
<p>在线编辑代码，在<code>get_model()</code>方法中返回一个Keras模型就能绘制出相应的结构图</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/net2vis.png" class="" title="Net2Vis">

<h2 id="Matlab"><a href="#Matlab" class="headerlink" title="Matlab"></a>Matlab</h2><h3 id="View-Neural-Network"><a href="#View-Neural-Network" class="headerlink" title="View Neural Network"></a>View Neural Network</h3><p>官方文档：<a href="http://www.mathworks.com/help/nnet/ref/view.html" target="_blank" rel="noopener">http://www.mathworks.com/help/nnet/ref/view.html</a></p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/matlab.png" class="" title="Matlab">

<h2 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h2><h3 id="Tensorboard"><a href="#Tensorboard" class="headerlink" title="Tensorboard"></a>Tensorboard</h3><p>主页：<a href="https://www.tensorflow.org/tensorboard" target="_blank" rel="noopener">https://www.tensorflow.org/tensorboard</a></p>
<p>Tensorboard就不用过多介绍了，用过Tensorflow的应该都知道这个工具，很多开源的Tensorflow机器学习模型都支持了Tensorboard，通过官方文档也很容易在自己的代码中集成Tensorboard</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/tensorboard.png" class="" title="Tensorboard">

<h3 id="TensorSpace-js"><a href="#TensorSpace-js" class="headerlink" title="TensorSpace.js"></a>TensorSpace.js</h3><p>Github地址：<a href="https://github.com/tensorspace-team/tensorspace" target="_blank" rel="noopener">https://github.com/tensorspace-team/tensorspace</a></p>
<p>主页：<a href="https://tensorspace.org/" target="_blank" rel="noopener">https://tensorspace.org/</a></p>
<p>使用方式：浏览器</p>
<p>TensorSpace是一套用于构建神经网络3D可视化应用的框架。TensorSpace 支持3D可视化经过适当预处理之后的 TensorFlow、Keras、TensorFlow.js 模型。</p>
<img src="/2020/07/24/how-to-visualize-neural-network-architectures/tensorspace.png" class="" title="TensorSpace">


<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://datascience.stackexchange.com/questions/12851/how-do-you-visualize-neural-network-architectures" target="_blank" rel="noopener">https://datascience.stackexchange.com/questions/12851/how-do-you-visualize-neural-network-architectures</a></li>
<li><a href="https://github.com/ashishpatel26/Tools-to-Design-or-Visualize-Architecture-of-Neural-Network" target="_blank" rel="noopener">https://github.com/ashishpatel26/Tools-to-Design-or-Visualize-Architecture-of-Neural-Network</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>联想R7000开箱上手以及ArchLinux安装</title>
    <url>/2020/07/03/lenovo-R7000-2020-unboxing-and-ArchLinux-installation/</url>
    <content><![CDATA[<p>今天是7月3日，距离我拿到这台2020款的联想R7000正好过去了一个月，用了一个月时间也有资格来聊聊联想的这台机器了。</p>
<p>先说说我这台联想R7000的具体配置吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPU: AMD Ryzen 7 4800H with Radeon Graphics (16) @ 2.900GHz</span><br><span class="line">Memory: 2 * 8G DDR4 3200MHz</span><br><span class="line">GPU: NVIDIA GeForce GTX 1650</span><br><span class="line">SSD: Samsung PM981a 512G</span><br><span class="line">SSD: Intel 760P 512G</span><br><span class="line">Wireless LAN Card: Intel Wi-Fi 6 AX200</span><br></pre></td></tr></table></figure>

<p>其中512G的Intel 760P是我自己加上的，机子原厂只自带了512G的Samsung PM981a。</p>
<p>这里简单放上一张<code>neofetch</code>截图：</p>
<img src="/2020/07/03/lenovo-R7000-2020-unboxing-and-ArchLinux-installation/neofetch.png" class="" title="neofetch">

<a id="more"></a>

<p>这款电脑我是以首发价格5599在京东入手的，算上一些优惠折扣，最终到手价是5529。要问这个价格买这个配置的电脑值不值，从我自己的使用体验来说是相当值的，这个预算如果去买Intel平台的笔电肯定买不到性能比这个强的。</p>
<p>一个月使用下来对这台电脑各方面都十分满意，不过还是鄙视一下联想R7000屏幕/内存/SSD抽奖。我买到的这一台是龙腾的屏幕，听说京东方的屏幕会比龙腾的屏幕好点，不过我也没见过京东方屏幕的R7000到底是怎么样的，简单测试了一下屏幕没有坏点也就懒得换货了，毕竟换回来的说不定还是龙腾的屏幕，最起码现在这个屏幕比我之前那个暗影精灵2看着舒服，就凑活着用吧（又不是不能用）。</p>
<p>既然聊到了前一台电脑，那就说说吧，四年前高考结束那会儿买的惠普暗(gǔ)影(bāo)精灵2花了4999，除了电池鼓包这个通病之外（也正是因为这个原因，以后再也不会考虑惠普的任何产品），整体用下来还是挺满意的，大学四年用下来没遇到过什么大毛病，后面我将内存升级到16G之后，日常使用更是没什么问题。唯一让我忍受不了想换电脑的就是CPU性能了，i5-6300hq的性能日常开个IDE写代码、编译程序的时候多多少少会有一点拖泥带水的感觉，CPU的占用总会上升到100%，随之而来就是各种操作都变得十分卡顿。</p>
<p>而R7000用下来，不管是写Java、Golang还是前端，编译速度都相当快，Jetbrains家的IDE索引速度也快了不少，写代码再也不会因为编译速度慢而浪费时间了。写Android后台开个虚拟机也十分流畅。</p>
<p>AMD 4800H这颗8C16T的CPU日常使用完全遇不到占用达到100%的情况，基本都在50%以下，CPU日常懒得动。</p>
<p>至于游戏方面的体验，因为我最近没怎么玩游戏，再加上买这台电脑并不是为了玩游戏的，所以还没有详细测试，只简单试了试CSGO全低特效能有200+fps左右，我已经很满足了。</p>
<p>其实从配置上来看，这是一台高U低显的电脑，至于为什么会选择这样配置的电脑，是我不想玩游戏了吗？那肯定不是，对于游戏我依旧是充满着热爱的，虽然现在玩游戏的时间变得越来越少了。选择这个配置的主要原因是，笔记本的CPU和显卡大多数是无法更换的，唯一能升级的也就内存跟SSD，用几年过后，CPU和显卡逐渐就跟不上主流了，这时候如果想升级配置就只能选择一整台换掉，我觉得这样太亏，所以笔记本电脑并不想选择配置太高的，在预算尽量少的情况下最大限度满足自己的需求就行，以后不再需要便携性的时候整个台式机比笔记本香多了，还能享受到DIY的乐趣呢。</p>
<p>联想的R7000要让我挑缺点的话，除了抽奖问题之外，我认为还有以下两个缺点：</p>
<ul>
<li>这台机子有两个M.2接口，但是其中一个M.2插槽跟SATA硬盘位是互斥的，没法同时安装SATA硬盘跟SSD</li>
<li>机子的16G内存是由两条8G内存组成的双通道，并且机器也只有两个内存插槽，后期如果要升级内存，就得买8G以上的内存条来换掉才行</li>
</ul>
<p>说了这么多，总结起来还是那六个字母、两个符号：<strong>AMD, YES!</strong></p>
<p>PS：Linux之父Linus Torvalds也<a href="http://lkml.iu.edu/hypermail/linux/kernel/2005.3/00406.html" target="_blank" rel="noopener">换到了AMD平台</a>，相信未来Linux内核对AMD平台的支持情况会越来越好。</p>
<h1 id="ArchLinux安装"><a href="#ArchLinux安装" class="headerlink" title="ArchLinux安装"></a>ArchLinux安装</h1><p>新机器到手，除了赶紧把自带的预装了联想全家桶的Windows 10家庭中文版换成专业版之外，最重要的就是装上ArchLinux了！平时写代码啥的还是ArchLinux用起来舒服，不仅仅是字体渲染看着比Windows清晰舒服，更重要的是很多事情都可以命令行一把梭，还不容易有各种各样奇奇怪怪的毛病（例如在开始菜单加入广告推荐Edge浏览器）。</p>
<p>ArchLinux的安装只需要按照官方Archwiki上的<a href="https://wiki.archlinux.org/index.php/Installation_guide" target="_blank" rel="noopener">Installation guide</a>一步步操作就行了，不过安装过程中如果是选择通过WiFi来接入互联网那马上就会遇到第一个问题：通过<code>wifi-menu</code>或者其他相关命令无法正常连接WiFi。</p>
<h2 id="WiFi连接"><a href="#WiFi连接" class="headerlink" title="WiFi连接"></a>WiFi连接</h2><p>第一次启动ArchLinux的安装镜像，习惯性使用<code>wifi-menu</code>连接WiFi，直接就报错了。难道是AX200这张无线网卡太新了，安装镜像还不支持？检查了一下驱动发现是没问题的。</p>
<p>翻了翻Google才发现，原来是机子所有的无线电接口都被bloacked了，解决方法也很简单，通过rfkill命令就能直接把所有的无线电接口都unblock：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rfkill unblock all</span><br></pre></td></tr></table></figure>

<p>执行完这条命令之后再执行<code>rfkill list</code>应该就能看到如下结果，所有的无线电接口的blocked状态都是no。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ rfkill list</span><br><span class="line">0: ideapad_wlan: Wireless LAN</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br><span class="line">1: ideapad_bluetooth: Bluetooth</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br><span class="line">2: phy0: Wireless LAN</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br><span class="line">3: hci0: Bluetooth</span><br><span class="line">        Soft blocked: no</span><br><span class="line">        Hard blocked: no</span><br></pre></td></tr></table></figure>

<p>这时候就能正常使用<code>wifi-menu</code>或其他相关的命令行连接WiFi，继续进行后续的安装操作了。</p>
<h2 id="屏蔽nouveau"><a href="#屏蔽nouveau" class="headerlink" title="屏蔽nouveau"></a>屏蔽nouveau</h2><p>不知道是不是因为GTX 1650这张显卡比较新，nouveau用起来总是会有一些奇奇怪怪的问题，偶尔还会导致系统关机的时候卡住，内核日志里也总会有很多关于nouveau的报错。</p>
<p>因为打算装NVIDIA的闭源驱动，所以我直接屏蔽了nouveau，省得再出现一些奇奇怪怪的问题，具体的屏蔽方法就是在<code>/etc/modprobe.d</code>目录下新建一个<code>disable-nouveau.conf</code>文件并写入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br></pre></td></tr></table></figure>

<p>这样下次开机进系统就不会加载nouveau驱动了，内核日志中也不会再出现一大堆关于nouveau的报错。</p>
<h2 id="屏幕亮度调节"><a href="#屏幕亮度调节" class="headerlink" title="屏幕亮度调节"></a>屏幕亮度调节</h2><p>这是我刚装上ArchLinux时遇到的第一个问题，屏幕亮度无法调节，开机直接就是最高亮度。</p>
<p>当时翻遍了ArchWiki和Google，尝试了很多解决方法，包括在Kernel启动参数后加上各种奇奇怪怪的启动参数（<code>acpi_osi=! acpi_osi=&quot;Windows 2009&quot;</code>、<code>acpi_backlight=vendor</code>等），直接向<code>/sys/class/backlight/amdgpu_bl0/brightness</code>中写入亮度数值都不行，然后就彻底放弃了，最高亮度凑活着用吧。</p>
<p>后来有一次从Windows重启到Linux的时候意外发现：先启动到Windows，然后在Windows上面选择重启，之后再进Linux就能正常调节亮度了。当时没有其他解决方法，所以只能每次用Linux都先启动到Windows，然后再重启进ArchLinux。</p>
<p>后面滚到5.7.6内核之后就能正常调节屏幕亮度了，但是随之而来又带来了新的问题，系统在播放音频或者是视频的时候，有一定的概率会卡死，就跟这个帖子描述的类似：<a href="https://bbs.archlinux.org/viewtopic.php?id=256929" target="_blank" rel="noopener">https://bbs.archlinux.org/viewtopic.php?id=256929</a>，kernel的日志也是一样的，初步怀疑是kernel某个patch有问题，又懒得自己编译内核，所以就先滚回5.7.5内核，最高亮度先用着，坐等内核更新。</p>
<p>终于，昨天更新了5.7.7内核之后，亮度调节正常，播放音/视频也不会再导致系统卡死了。R7000装Linux遇到屏幕亮度无法调节的可以将内核升级到5.7.7试试，应该就能调节了。</p>
<h2 id="AMD-NVIDIA双显卡切换"><a href="#AMD-NVIDIA双显卡切换" class="headerlink" title="AMD/NVIDIA双显卡切换"></a>AMD/NVIDIA双显卡切换</h2><p>R7000是支持在BIOS中设置成独显直连的，但是我并不想让Linux直接在独显上跑，不仅费电，还容易发热，日常写代码感觉也不需要用上独显，所以我还是更喜欢双显卡切换，毕竟集成显卡也是花了钱买的嘛，怎么能就这么放着不用呢。</p>
<p>之前暗影精灵2上面是使用bumblebee的方案来管理双显卡的，但是bumblebee似乎只支持Intel+NVIDIA双显卡，不支持AMD+NVIDIA双显卡。那就只能寻找新的解决方案了。</p>
<p>所以就去爬了爬ArchWiki上的<a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus" target="_blank" rel="noopener">NVIDIA Optimus</a>，最终决定采用<a href="https://github.com/Askannz/optimus-manager/" target="_blank" rel="noopener">optimus-manager</a>来管理双显卡。</p>
<h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><p>AMD集成显卡的驱动使用<code>xf86-video-amdgpu</code>，NVIDIA独立显卡的驱动使用NVIDIA闭源驱动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S xf86-video-amdgpu</span><br><span class="line">sudo pacman -S nvidia nvidia-settings nvidia-utils lib32-nvidia-utils</span><br></pre></td></tr></table></figure>

<h3 id="安装Optimus-Manager"><a href="#安装Optimus-Manager" class="headerlink" title="安装Optimus Manager"></a>安装Optimus Manager</h3><p>首先需要安装optimus-manager， 因为是AMD平台，所以不能直接安装原版的optimus-manager，必须安装AMD分支版本<a href="https://aur.archlinux.org/packages/optimus-manager-amd-git/" target="_blank" rel="noopener">optimus-manager-amd-git</a><sup>AUR</sup>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S optimus-manager-amd-git</span><br></pre></td></tr></table></figure>

<p>同时bbswitch也得替换成<a href="https://aur.archlinux.org/packages/bbswitch-ati-git/" target="_blank" rel="noopener">bbswitch-ati-git</a><sup>AUR</sup>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S bbswitch-ati-git</span><br></pre></td></tr></table></figure>

<p>都安装好了之后开启服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> optimus-manager.service</span><br></pre></td></tr></table></figure>

<p>同时需要确保<code>/etc/X11/xorg.conf</code> 和 <code>/etc/X11/xorg.conf.d</code> 下面没有显示相关的配置文件</p>
<h3 id="配置Optimus-Manager"><a href="#配置Optimus-Manager" class="headerlink" title="配置Optimus Manager"></a>配置Optimus Manager</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/optimus-manager</span><br><span class="line">sudo cp /usr/share/optimus-manager.conf /etc/optimus-manager/optimus-manager.conf</span><br></pre></td></tr></table></figure>

<p>然后编辑<code>/etc/optimus-manager/optimus-manager.conf</code>文件，根据文件内的注释说明进行optimus-manager的配置。</p>
<p>这里贴一下我自己用的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[optimus]</span><br><span class="line"></span><br><span class="line"># This parameter defines the method used to power switch the Nvidia card. See the documentation</span><br><span class="line"># for a complete description of what each value does. Possible values :</span><br><span class="line">#</span><br><span class="line"># - nouveau : load the nouveau module on the Nvidia card.</span><br><span class="line"># - bbswitch : power off the card using the bbswitch module (requires the bbswitch dependency).</span><br><span class="line"># - acpi_call : try various ACPI method calls to power the card on and off (requires the acpi_call dependency)</span><br><span class="line"># - none : do not use an external module for power management. For some laptop models it&#39;s preferable to</span><br><span class="line">#           use this option in combination with pci_power_control (see below).</span><br><span class="line">#           With that option set, you can also use the scripts nvidia-enable.sh and nvidia-disable.sh to</span><br><span class="line">#           execute custom commands for power management.</span><br><span class="line">switching&#x3D;none</span><br><span class="line"></span><br><span class="line"># Enable PCI power management in Intel mode.</span><br><span class="line"># This option is incompatible with acpi_call and bbswitch, so it will be ignored in those cases.</span><br><span class="line">pci_power_control&#x3D;yes</span><br><span class="line"></span><br><span class="line"># Remove the Nvidia card from the PCI bus.</span><br><span class="line"># May prevent crashes caused by power switching.</span><br><span class="line"># Ignored if switching&#x3D;nouveau or switching&#x3D;bbswitch.</span><br><span class="line">pci_remove&#x3D;no</span><br><span class="line"></span><br><span class="line"># Reset the Nvidia card at the PCI level before reloading the nvidia module.</span><br><span class="line"># Ensures the card is in a fresh state before reloading the nvidia module.</span><br><span class="line"># May fix some switching issues. Possible values :</span><br><span class="line">#</span><br><span class="line"># - no : does not perform any reset</span><br><span class="line"># - function_level : perform a light &quot;function-level&quot; reset</span><br><span class="line"># - hot_reset : perform a &quot;hot reset&quot; of the PCI bridge. ATTENTION : this method messes with the hardware</span><br><span class="line">#         directly, please read the online documentation of optimus-manager before using it.</span><br><span class="line">#         Also, it will perform a PCI remove even if pci_remove&#x3D;no.</span><br><span class="line">#</span><br><span class="line">pci_reset&#x3D;no</span><br><span class="line"></span><br><span class="line"># Automatically log out the current desktop session when switching GPUs.</span><br><span class="line"># This feature is currently supported for the following DE&#x2F;WM :</span><br><span class="line"># KDE Plasma, GNOME, XFCE, Deepin, i3, Openbox, AwesomeWM, bspwm</span><br><span class="line"># If this option is disabled or you use a different desktop environment,</span><br><span class="line"># GPU switching only becomes effective at the next graphical session login.</span><br><span class="line">auto_logout&#x3D;yes</span><br><span class="line"></span><br><span class="line"># The mode used with startup mode ac_auto when not connected to AC.</span><br><span class="line"># Possible values : amd, intel, hybrid-amd, hybrid-intel</span><br><span class="line">ac_auto_battery_mode&#x3D;amd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The mode used with startup mode ac_auto when connected to AC.</span><br><span class="line"># Possible values : hybrid, nvidia</span><br><span class="line">ac_auto_extpower_mode&#x3D;nvidia</span><br><span class="line"></span><br><span class="line">[intel]</span><br><span class="line"></span><br><span class="line"># Driver to use for the Intel GPU. Possible values : modesetting, intel</span><br><span class="line"># To use the intel driver, you need to install the package &quot;xf86-video-intel&quot;.</span><br><span class="line">driver&#x3D;modesetting</span><br><span class="line"></span><br><span class="line"># Acceleration method (corresponds to AccelMethod in the Xorg configuration).</span><br><span class="line"># Only applies to the intel driver.</span><br><span class="line"># Possible values : sna, xna</span><br><span class="line"># Leave blank for the default (no option specified)</span><br><span class="line">accel&#x3D;</span><br><span class="line"></span><br><span class="line"># Enable TearFree option in the Xorg configuration.</span><br><span class="line"># Only applies to the intel driver.</span><br><span class="line"># Possible values : yes, no</span><br><span class="line"># Leave blank for the default (no option specified)</span><br><span class="line">tearfree&#x3D;</span><br><span class="line"></span><br><span class="line"># DRI version. Possible values : 2, 3</span><br><span class="line">DRI&#x3D;3</span><br><span class="line"></span><br><span class="line"># Whether or not to enable modesetting for the nouveau driver.</span><br><span class="line"># Does not affect modesetting for the Intel GPU driver !</span><br><span class="line"># This option only matters if you use nouveau as the switching backend.</span><br><span class="line">modeset&#x3D;yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[amd]</span><br><span class="line"></span><br><span class="line"># Driver to use for the AMD GPU. Possible values : modesetting, amdgpu</span><br><span class="line"># To use the amdgpu driver, you need to install the package &quot;xf86-video-amdgpu&quot;.</span><br><span class="line">driver&#x3D;amdgpu</span><br><span class="line"></span><br><span class="line"># Enable TearFree option in the Xorg configuration.</span><br><span class="line"># Only applies to the amdgpu driver.</span><br><span class="line"># Possible values : yes, no</span><br><span class="line"># Leave blank for the default (no option specified)</span><br><span class="line">tearfree&#x3D;</span><br><span class="line"></span><br><span class="line"># DRI version. Possible values : 2, 3</span><br><span class="line">DRI&#x3D;3</span><br><span class="line"></span><br><span class="line"># Whether or not to enable modesetting for the nouveau driver.</span><br><span class="line"># Does not affect modesetting for the AMD GPU driver !</span><br><span class="line"># This option only matters if you use nouveau as the switching backend.</span><br><span class="line">modeset&#x3D;yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[nvidia]</span><br><span class="line"></span><br><span class="line"># Whether or not to enable modesetting. Required for PRIME Synchronization (which prevents tearing).</span><br><span class="line">modeset&#x3D;yes</span><br><span class="line"></span><br><span class="line"># Whether or not to enable the NVreg_UsePageAttributeTable option in the Nvidia driver.</span><br><span class="line"># Recommended, can cause poor CPU performance otherwise.</span><br><span class="line">PAT&#x3D;yes</span><br><span class="line"></span><br><span class="line"># DPI value. This will be set using the Xsetup script passed to your login manager.</span><br><span class="line"># It will run the command</span><br><span class="line"># xrandr --dpi &lt;DPI&gt;</span><br><span class="line"># Leave blank for the default (the above command will not be run).</span><br><span class="line">DPI&#x3D;96</span><br><span class="line"></span><br><span class="line"># If you&#39;re running an updated version of xorg-server (let&#39;s say to get PRIME Render offload enabled),</span><br><span class="line"># the nvidia driver may not load because of an ABI version mismatch. Setting this flag to &quot;yes&quot;</span><br><span class="line"># will allow the loading of the nvidia driver.</span><br><span class="line">ignore_abi&#x3D;no</span><br><span class="line"></span><br><span class="line"># Set to yes if you want to use optimus-manager with external Nvidia GPUs (experimental)</span><br><span class="line">allow_external_gpus&#x3D;no</span><br><span class="line"></span><br><span class="line"># Comma-separated list of Nvidia-specific options to apply.</span><br><span class="line"># Available options :</span><br><span class="line"># - overclocking : enable CoolBits in the Xorg configuration, which unlocks clocking options</span><br><span class="line">#   in the Nvidia control panel. Note: does not work in hybrid mode.</span><br><span class="line"># - triple_buffer : enable triple buffering.</span><br><span class="line">options&#x3D;</span><br></pre></td></tr></table></figure>

<p>关于我的这份配置文件：</p>
<ul>
<li>switching method不使用bbswitch是因为使用集成显卡的时候通过bbswitch关闭独立显卡会导致电脑的风扇以最高转速狂转，可能是因为关闭了独立显卡电源之后，系统无法正常读取独显温度导致将风扇调至最高转速，暂时没有找到一个比较靠谱的解决方法，所以就先用none，也许未来BIOS升级之后能解决这个问题</li>
<li>正是因为switching method选择了none，所以把pci_power_control启用了，让PCI power management管理独显的电源</li>
<li>AMD的driver使用amdgpu</li>
<li>其余配置基本都是默认配置</li>
</ul>
<p>一些都配置好了就重启电脑吧，如果没有什么意外的话，Optimus Manager已经正常工作了。</p>
<h3 id="Optimus-Manager用法"><a href="#Optimus-Manager用法" class="headerlink" title="Optimus Manager用法"></a>Optimus Manager用法</h3><ul>
<li><p>切换到NVIDIA：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">optimus-manager --switch nvidia</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到AMD：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">optimus-manager --switch amd</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机使用AMD：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">optimus-manager --<span class="built_in">set</span>-startup=amd</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示当前模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">optimus-manager --<span class="built_in">print</span>-mode</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示开机使用的模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">optimus-manager --<span class="built_in">print</span>-startup</span><br></pre></td></tr></table></figure>
</li>
<li><p>更多用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">optimus-manager --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Optimus-Manager-GUI"><a href="#Optimus-Manager-GUI" class="headerlink" title="Optimus Manager GUI"></a>Optimus Manager GUI</h3><ul>
<li><p><a href="https://github.com/Shatur95/optimus-manager-qt" target="_blank" rel="noopener">Optimus Manager Qt</a></p>
<img src="/2020/07/03/lenovo-R7000-2020-unboxing-and-ArchLinux-installation/optimus-manager-qt.png" class="" title="optimus-manager-qt">
</li>
<li><p>Argos Script For Optimus-Manager</p>
<img src="/2020/07/03/lenovo-R7000-2020-unboxing-and-ArchLinux-installation/argos-optimus-manager.png" class="" title="argos-optimus-manager">

<p>由于<a href="https://github.com/inzar98/optimus-manager-argos" target="_blank" rel="noopener">原版的optimus-manager-argos</a>不支持AMD显卡的切换，同时也停止维护了，所以我Fork了一份，加上了AMD的支持：<a href="https://github.com/LGiki/optimus-manager-argos" target="_blank" rel="noopener">https://github.com/LGiki/optimus-manager-argos</a></p>
</li>
</ul>
<h2 id="触摸板"><a href="#触摸板" class="headerlink" title="触摸板"></a>触摸板</h2><p>是的，这台机器的触摸板在Linux下无法正常使用，触摸跟按键都没有任何反应。</p>
<p>在内核日志上可以找到关于触摸板的报错内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[    1.981868] i2c_hid i2c-MSFT0001:00: supply vdd not found, using dummy regulator</span><br><span class="line">[    1.981883] i2c_hid i2c-MSFT0001:00: supply vddl not found, using dummy regulator</span><br><span class="line">[    7.064976] i2c_hid i2c-MSFT0001:00: failed to reset device.</span><br><span class="line">[   13.251401] i2c_hid i2c-MSFT0001:00: failed to reset device.</span><br><span class="line">[   19.438327] i2c_hid i2c-MSFT0001:00: failed to reset device.</span><br><span class="line">[   25.624986] i2c_hid i2c-MSFT0001:00: failed to reset device.</span><br><span class="line">[   26.638144] i2c_hid i2c-MSFT0001:00: can&#39;t add hid device: -61</span><br><span class="line">[   26.638591] i2c_hid: probe of i2c-MSFT0001:00 failed with error -61</span><br></pre></td></tr></table></figure>

<p>找到了一个相关的讨论：<a href="https://bugzilla.kernel.org/show_bug.cgi?id=207759" target="_blank" rel="noopener">https://bugzilla.kernel.org/show_bug.cgi?id=207759</a></p>
<p>因为我日常几乎用不到笔记本的触摸板，平时都是用鼠标，所以也懒得再去研究这个问题了，说不定随着内核的更新，触摸板突然就能用了呢（想peach）。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开箱</tag>
        <tag>体验</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么中国亲戚总是喜欢给建议？</title>
    <url>/2020/06/08/why-chinese-relatives-always-like-to-give-fking-advice/</url>
    <content><![CDATA[<p>为什么中国亲戚总是喜欢给建议？</p>
<a id="more"></a>

<p>这是我从小到大就一直很想搞清楚的问题，可是我长这么大了却从没想明白这个问题的答案到底是什么。也许中国的亲戚们与生俱来就是喜欢打听别人的家底，总是喜欢给出各种看似很完美的建议来凸显自己才智过人，自己是多么成功。可是…他们真的成功吗？他们有给建议的资格吗？他们家的孩子就真的有按照他的这些建议一步步成长吗？</p>
<p>每次亲戚聚会我都是最害怕的，经常是自己一个人躲在角落里，不出声，也不想起来走动，低着头玩着自己的手机，生怕亲戚的余光往我这边飘。</p>
<p>我在家族里边是年龄最小的，其他兄弟姐妹都已经工作了，只有我还在上学，所以每次家庭聚会亲戚们都不可避免会把话题扯到我身上，问我学习情况、问我是否准备考研、问我是否准备考公务员、问我找女朋友了没有，只要是他们能想到的我还没经历过的事情统统都会问我一遍，然后再针对每个问题给出他们的建议：“还是考个研究生吧，文凭高一点未来也好就业”、“你头发太长了，赶紧去剪短一点”、“都大学毕业了，可以赶紧去找个女朋友了”。每次跟亲戚吃饭也是，经常是明明已经吃得很饱并且再三强调不想吃了，亲戚们还硬是疯狂往我碗里夹菜，看似热情好客，却从不考虑他人的感受。</p>
<p>以上这些可能随便应付一下就过去了，我也不会太把这些问题当回事。但是今天，一个亲戚突然发消息给我，让我去考个公务员试试…我是真的没想懂这个亲戚为什么会这么对我说，我都听从父母以及亲戚的各种教唆，已经研究生预录取马上就要去读研了，然后现在叫我去考公务员？</p>
<p>说真的，我是完全不知道如何去面对亲戚提出的问题和建议，我也不知道我为什么要一直顺从亲戚们给的各种建议生活，可能自己天生就没有主见也不够强势吧。</p>
<p>我害怕家庭聚会，害怕遇到亲戚，害怕亲戚的头像出现在微信的消息通知里，害怕微信家族群出现关于我的任何讨论。甚至梦里有时候都会被亲戚的各种噩梦给吓醒。</p>
<p>希望自己未来不要成为这样的亲戚，扼杀孩子的梦想是最残酷也是最恶毒的行为，永远不要用自己的思维定势去禁锢孩子的想法。</p>
<p>如果未来我能有孩子，我希望Ta能够自由去探索自己感兴趣的事物，自由选择自己以后的工作，而不需要无力顺从各种建议，这样只会毁了孩子的好奇心。</p>
<p>当然，我现在连结婚都觉得恐惧，未来还真不一定会有孩子，一个人活着真的蛮好的。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>自闭</tag>
      </tags>
  </entry>
</search>
